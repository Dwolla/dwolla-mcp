/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import express from "express";
import { SDKOptions } from "../../../lib/config.js";
import { LocalContext } from "../../cli.js";
import {
  ConsoleLoggerLevel,
  createConsoleLogger,
} from "../../console-logger.js";
import { MCPScope } from "../../scopes.js";
import { createMCPServer } from "../../server.js";

interface StartCommandFlags {
  readonly transport: "stdio" | "http";
  readonly port: number;
  readonly tool?: string[];
  readonly scope?: MCPScope[];
  readonly "server-url"?: string;
  readonly "server-index"?: SDKOptions["serverIdx"];
  readonly "log-level": ConsoleLoggerLevel;
  readonly env?: [string, string][];
}

export async function main(this: LocalContext, flags: StartCommandFlags) {
  flags.env?.forEach(([key, value]) => {
    process.env[key] = value;
  });

  switch (flags.transport) {
    case "stdio":
      await startStdio(flags);
      break;
    case "http":
      await startStreamableHTTP(flags);
      break;
    default:
      throw new Error(`Invalid transport: ${flags.transport}`);
  }
}

async function startStdio(flags: StartCommandFlags) {
  const logger = createConsoleLogger(flags["log-level"]);
  const transport = new StdioServerTransport();
  const server = createMCPServer({
    logger,
    allowedTools: flags.tool,
    scopes: flags.scope,
    // Security moved to per-request in Phase 3+
    serverURL: flags["server-url"],
    serverIdx: flags["server-index"],
  });
  await server.connect(transport);

  const abort = async () => {
    await server.close();
    process.exit(0);
  };
  process.on("SIGTERM", abort);
  process.on("SIGINT", abort);
}

async function startStreamableHTTP(flags: StartCommandFlags) {
  const logger = createConsoleLogger(flags["log-level"]);
  const app = express();
  app.use(express.json());
  
  const mcpServer = createMCPServer({
    logger,
    allowedTools: flags.tool,
    scopes: flags.scope,
    // Security moved to per-request in Phase 3+
    serverURL: flags["server-url"],
    serverIdx: flags["server-index"],
  });
  const controller = new AbortController();

  // Health check endpoint
  app.get("/health", (_req, res) => {
    res.json({ status: "ok", timestamp: new Date().toISOString() });
  });

  // Single endpoint handles all MCP communication
  app.all("/mcp", async (req, res) => {
    try {
      // Validate Authorization header per MCP spec before processing
      if (!req.headers.authorization || !req.headers.authorization.startsWith('Bearer ')) {
        res.status(401).json({
          jsonrpc: '2.0',
          error: {
            code: -32001,
            message: 'Unauthorized: Missing or invalid Authorization header'
          },
          id: null
        });
        return;
      }
      
      // Extract and store token for tools to access
      const token = req.headers.authorization.substring(7); // Remove 'Bearer ' prefix
      
      // Create fresh server and transport per request for stateless behavior
      const requestServer = createMCPServer({
        logger,
        allowedTools: flags.tool,
        scopes: flags.scope,
        serverURL: flags["server-url"],
        serverIdx: flags["server-index"],
        authToken: token, // Pass token to server creation
      });
      
      const transport = new StreamableHTTPServerTransport({
        sessionIdGenerator: undefined,
      });
      
      await requestServer.connect(transport);
      await transport.handleRequest(req, res, req.body);
      
      res.on('close', () => {
        transport.close();
        requestServer.close();
      });
    } catch (error) {
      logger.error("Error handling MCP request", { error });
      res.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32603,
          message: 'Internal server error'
        },
        id: null
      });
    }
  });

  const httpServer = app.listen(flags.port, "0.0.0.0", () => {
    const ha = httpServer.address();
    const host = typeof ha === "string" ? ha : `${ha?.address}:${ha?.port}`;
    logger.info("MCP HTTP server started", { host });
  });

  let closing = false;
  controller.signal.addEventListener("abort", async () => {
    if (closing) {
      logger.info("Received second signal. Forcing shutdown.");
      process.exit(1);
    }
    closing = true;

    logger.info("Shutting down MCP server");

    await mcpServer.close();

    logger.info("Shutting down HTTP server");

    const timer = setTimeout(() => {
      logger.info("Forcing shutdown");
      process.exit(1);
    }, 5000);

    httpServer.close(() => {
      clearTimeout(timer);
      logger.info("Graceful shutdown complete");
      process.exit(0);
    });
  });

  const abort = () => controller.abort();
  process.on("SIGTERM", abort);
  process.on("SIGINT", abort);
}
