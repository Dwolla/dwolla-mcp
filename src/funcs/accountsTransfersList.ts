/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { DwollaMcpCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { APIError } from "../models/errors/apierror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import {
  ListAndSearchTransfersRequest,
  ListAndSearchTransfersRequest$zodSchema,
  ListAndSearchTransfersResponse,
  ListAndSearchTransfersResponse$zodSchema,
} from "../models/listandsearchtransfersop.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List and search account transfers
 *
 * @remarks
 * Returns a paginated, searchable list of transfers associated with the specified Main Dwolla account. Supports advanced filtering by amount range, date range, transfer status, and correlation ID. Results are limited to 10,000 transfers per query; use date range filters for historical data beyond this limit.
 */
export function accountsTransfersList(
  client$: DwollaMcpCore,
  request: ListAndSearchTransfersRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    ListAndSearchTransfersResponse,
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >
> {
  return new APIPromise($do(
    client$,
    request,
    options,
  ));
}

async function $do(
  client$: DwollaMcpCore,
  request: ListAndSearchTransfersRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      ListAndSearchTransfersResponse,
      | APIError
      | SDKValidationError
      | UnexpectedClientError
      | InvalidRequestError
      | RequestAbortedError
      | RequestTimeoutError
      | ConnectionError
    >,
    APICall,
  ]
> {
  const parsed$ = safeParse(
    request,
    (value$) => ListAndSearchTransfersRequest$zodSchema.parse(value$),
    "Input validation failed",
  );
  if (!parsed$.ok) {
    return [parsed$, { status: "invalid" }];
  }
  const payload$ = parsed$.value;
  const body$ = null;

  const pathParams$ = {
    id: encodeSimple("id", payload$.id, {
      explode: false,
      charEncoding: "percent",
    }),
  };
  const path$ = pathToFunc("/accounts/{id}/transfers")(
    pathParams$,
  );
  const query$ = encodeFormQuery({
    "correlationId": payload$.correlationId,
    "endAmount": payload$.endAmount,
    "endDate": payload$.endDate,
    "limit": payload$.limit,
    "offset": payload$.offset,
    "search": payload$.search,
    "startAmount": payload$.startAmount,
    "startDate": payload$.startDate,
    "status": payload$.status,
  });

  const headers$ = new Headers(compactMap({
    Accept: "application/vnd.dwolla.v1.hal+json",
  }));
  const securityInput = await extractSecurity(client$._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client$._options,
    baseURL: options?.serverURL ?? client$._baseURL ?? "",
    operationID: "listAndSearchTransfers",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client$._options.security,
    retryConfig: options?.retries
      || client$._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || [
      "429",
      "500",
      "502",
      "503",
      "504",
    ],
  };

  const requestRes = client$._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path$,
    headers: headers$,
    query: query$,
    body: body$,
    userAgent: client$._options.userAgent,
    timeoutMs: options?.timeoutMs || client$._options.timeoutMs
      || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req$ = requestRes.value;

  const doResult = await client$._do(req$, {
    context,
    errorCodes: [],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req$ }];
  }
  const response = doResult.value;
  const responseFields$ = {
    HttpMeta: { Response: response, Request: req$ },
  };

  const [result$] = await M.match<
    ListAndSearchTransfersResponse,
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >(
    M.json(200, ListAndSearchTransfersResponse$zodSchema, {
      ctype: "application/vnd.dwolla.v1.hal+json",
      key: "Transfers",
    }),
    M.json(404, ListAndSearchTransfersResponse$zodSchema, {
      ctype: "application/vnd.dwolla.v1.hal+json",
      key: "object",
    }),
  )(response, req$, { extraFields: responseFields$ });

  return [result$, { status: "complete", request: req$, response }];
}
